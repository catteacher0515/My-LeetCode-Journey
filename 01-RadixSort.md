# 基数排序：一个“强迫症”图书管理员的故事

想象一下，你是一个图书管理员，面前有一堆刚到的新书，书脊上贴着数字编号，顺序完全是乱的。

-   **书本编号 `arr`**: `{170, 45, 75, 90, 802, 24, 2, 66}`

你的任务，是把这些书按照编号从小到大排在书架上。

但你有个奇怪的**“毛病”**：你无法直接比较 `170` 和 `802` 哪个大，你看一眼多位数就头晕。你唯一擅长且**痴迷的**，就是识别 **`0-9`** 这十个单独的数字。于是，你决定用自己独特的方法来完成这个工作。

---

## 第一步：准备工作 (代码中的 `radixSort` 方法)

你做的第一件事，是快速翻看所有书，找到编号最大的那个。你找到了 **`802`**。

你心里想：“哦，最大的数是**三位数**。这意味着我的工作需要进行**三轮**。”

这对应代码里的循环，它正是通过最大值来确定需要循环几轮：
```java
for (int exp = 1; max / exp > 0; exp *= 10)
````

-----

## 第二步：第一轮排序 —— 只看“个位数” (`exp = 1`)

你清空了一张大桌子，在上面放了10个贴着 `0` 到 `9` 标签的箱子。

> 你宣布：“第一轮开始！现在，所有人都忘记十位和百位，我们只根据\*\*‘个位数’\*\*来分拣！”

你拿起书本，一本一本地处理：

  - **`170`** -\> 个位数是 **`0`** -\> 扔进 **0号箱**。
  - **`45`** -\> 个位数是 **`5`** -\> 扔进 **5号箱**。
  - **`75`** -\> 个位数是 **`5`** -\> 扔进 **5号箱**。
  - **`90`** -\> 个位数是 **`0`** -\> 扔进 **0号箱**。
  - **`802`** -\> 个位数是 **`2`** -\> 扔进 **2号箱**。
  - **`24`** -\> 个位数是 **`4`** -\> 扔进 **4号箱**。
  - **`2`** -\> 个位数是 **`2`** -\> 扔进 **2号箱**。
  - **`66`** -\> 个位数是 **`6`** -\> 扔进 **6号箱**。

现在，所有的书都在箱子里了。你开始按箱子编号，从0号到9号，依次把里面的书拿出来，重新堆成一摞。在同一个箱子里，你**保持它们被扔进去的先后顺序**。

  - 从 **0号箱** 拿出: `170`, `90`
  - 从 **2号箱** 拿出: `802`, `2`
  - 从 **4号箱** 拿出: `24`
  - 从 **5号箱** 拿出: `45`, `75`
  - 从 **6号箱** 拿出: `66`

第一轮结束后，你的书本顺序变成了：
`{170, 90, 802, 2, 24, 45, 75, 66}`

**检视成果**：如果你只看这些编号的个位数 (`0, 0, 2, 2, 4, 5, 5, 6`)，会发现它们已经**完美有序**了！

-----

## 第三步：第二轮排序 —— 只看“十位数” (`exp = 10`)

你完全不理会现在的整体顺序，而是拿起这摞新顺序的书，宣布：

> “第二轮开始！现在，所有人忘记个位和百位，我们只根据\*\*‘十位数’\*\*来分拣！”

你再次把它们扔进0-9号箱：

  - **`170`** -\> 十位数是 **`7`** -\> 扔进 **7号箱**。
  - **`90`** -\> 十位数是 **`9`** -\> 扔进 **9号箱**。
  - **`802`** -\> 十位数是 **`0`** -\> 扔进 **0号箱**。
  - **`2`** (002) -\> 十位数是 **`0`** -\> 扔进 **0号箱**。
  - **`24`** -\> 十位数是 **`2`** -\> 扔进 **2号箱**。
  - **`45`** -\> 十位数是 **`4`** -\> 扔进 **4号箱**。
  - **`75`** -\> 十位数是 **`7`** -\> 扔进 **7号箱**。
  - **`66`** -\> 十位数是 **`6`** -\> 扔进 **6号箱**。

再次按箱子编号，把书拿出来堆成一摞：

  - 从 **0号箱** 拿出: `802`, `2`
  - 从 **2号箱** 拿出: `24`
  - 从 **4号箱** 拿出: `45`
  - 从 **6号箱** 拿出: `66`
  - 从 **7号箱** 拿出: `170`, `75`
  - 从 **9号箱** 拿出: `90`

第二轮结束后，你的书本顺序变成了：
`{802, 2, 24, 45, 66, 170, 75, 90}`

**检视成果**：现在，如果你只看十位数 (`0, 0, 2, 4, 6, 7, 7, 9`)，它们也已经**完美有序**了。而且你发现一个奇妙的现象：在十位数相同的书里（比如`802`和`2`），它们的原始相对顺序（上一轮排好的个位顺序）被保留了下来！这就是\*\*“稳定性”\*\*的魔力。

-----

## 第四步：第三轮排序 —— 只看“百位数” (`exp = 100`)

你拿起这摞更新后的书，进行最后的工作：

> “第三轮开始！所有人忘记个位和十位，我们只根据\*\*‘百位数’\*\*来分拣！”

再次扔箱子：

  - **`802`** -\> 百位数是 **`8`** -\> 扔进 **8号箱**。
  - **`2`, `24`, `45`, `66`, `75`, `90`** 的百位数都是 **`0`** -\> 全部扔进 **0号箱**。
  - **`170`** -\> 百位数是 **`1`** -\> 扔进 **1号箱**。

最后一次，按箱子编号把书拿出来：

  - 从 **0号箱** 拿出: `2, 24, 45, 66, 75, 90`
  - 从 **1号箱** 拿出: `170`
  - 从 **8号箱** 拿出: `802`

-----

## 剧终：大功告成

你看着最后拿出来的这摞书，顺序是：

```
{2, 24, 45, 66, 75, 90, 170, 802}
```

你满意地发现，虽然你一次都没有比较过两个完整的数字，但仅仅通过三轮\*\*“低维”\*\*的、**机械化**的分拣，整摞书已经完美地从大到小排好序了。

这就是基数排序的魔力：**后一轮的排序，会建立在前一轮排序结果的基础上**。只要你每一轮的分拣和收集都是\*\*“稳定”**的（不打乱相同数位元素的旧顺序），那么当处理完最高位时，之前所有低位的排序结果就都被**奇迹般地保留\*\*了下来，从而实现了整体的有序。

```
```
