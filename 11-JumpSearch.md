好的，我们这就把跳跃查找，特别是我们深入讨论过的、它与二分查找的对比，都完整地沉淀下来。

这篇笔记会特别强调你提出的那个关键问题：“**为什么这道题（搜索插入位置）更适合用二分查找？**”，这能帮你建立起在不同算法间做“选择”的思维模型。

**文件名建议**：`Algorithm-Jump-Search.md`

-----

````markdown
# 查找算法：跳跃查找 (Jump Search)

跳跃查找（Jump Search）是一种在**有序数组**中进行查找的算法。它的性能介于线性查找 ($O(n)$) 和二分查找 ($O(\log n)$) 之间，其核心思想是“先跳跃，再线性查找”。

## 1. 核心思想：先“跳”再“走”

跳跃查找的策略，可以比作“**青蛙王子寻宝**”：

1.  **制定计划（确定步长）**: 王子面对一条很长的小路（有序数组），他决定不一步一步走，也不来回传送，而是采用自己最擅长的**跳跃**。他计算出一个最佳的跳跃距离（步长 `step`，通常是 `√n`）。
2.  **大步跳跃 (Jump Phase)**: 他按照固定的步长，一次次地向前跳。在每一跳的落点，他都会检查一下那个位置的元素。只要落点元素还比目标值 `target` 小，他就可以安心地继续向前跳。
3.  **锁定区间**: 当他某一跳的落点元素**大于** `target` 时，他就知道自己“跳过头”了。此时，他可以百分之百地确定，`target`（如果存在的话）一定在他**上一次起跳的位置**和他**当前的位置**之间。
4.  **小步线性走 (Linear Search Phase)**: 王子回到上一次起跳的位置，然后在这个被锁定的、很小的区间内，**一步一步地**向前进行线性查找，直到找到 `target` 或确认它不存在。

这个“**大步跳跃锁定范围，再线性确认位置**”的混合策略，就是跳跃查找的精髓。

## 2. Java 代码实现

```java
public class JumpSearch {
    public static int jumpSearch(int[] arr, int target) {
        int n = arr.length;
        if (n == 0) return -1;

        // 1. 确定最佳步长
        int step = (int) Math.floor(Math.sqrt(n));

        // 2. 跳跃查找阶段
        int prev = 0;
        // 只要当前块的末尾元素还小于 target，就继续向前跳
        while (arr[Math.min(step, n) - 1] < target) {
            prev = step; // 记录上一个起跳点
            step += (int) Math.floor(Math.sqrt(n));
            if (prev >= n) { // 如果起跳点已经超出数组，说明找不到
                return -1;
            }
        }

        // 3. 线性查找阶段
        // 在 [prev, step] 区间内进行线性查找
        while (arr[prev] < target) {
            prev++;
            // 如果走到了区间的末尾，说明找不到
            if (prev == Math.min(step, n)) {
                return -1;
            }
        }

        // 4. 最终确认
        // 检查线性查找停止的位置是否正好是 target
        if (arr[prev] == target) {
            return prev;
        }

        return -1;
    }
}
````

### 关键代码解析

  - **`Math.sqrt(n)`**: 这是被证明过的**最优步长**，它能在“跳跃次数”和“线性查找次数”之间取得最佳平衡。
  - **`Math.min(step, n)`**: 这是一个重要的**安全检查**，用于防止 `step` 指针在跳跃时超出数组的实际长度 `n`，从而避免“数组下标越界”的错误。

-----

## 3\. 深度辨析：跳跃查找 vs. 二分查找

这是理解跳跃查找适用场景的关键。

| 特征 (Feature) | 跳跃查找 (Jump Search) | 二分查找 (Binary Search) |
| :--- | :--- | :--- |
| **时间复杂度** | **$O(\\sqrt{n})$** | **$O(\\log n)$** (更快) |
| **核心操作** | **向前跳跃** + **向前线性扫描** | **向中间跳跃**，来回折半 |
| **内存访问** | 访问模式是**单向向前**的 | 访问模式是**随机**的（中间、1/4、3/8...） |
| **适用场景** | 理论上，在随机内存访问成本极高的特殊硬件上可能有优势 | **绝大多数**有序数组查找场景的**最优选择** |

### 为什么“搜索插入位置”这道题不适合用跳跃查找？

你在这个问题上的判断是完全正确的，原因有二：

1.  **时间复杂度不达标**:

      * 题目明确要求时间复杂度为 **$O(\\log n)$**。
      * 跳跃查找的 $O(\\sqrt{n})$ 无法满足这个硬性指标。对于 `n=1,000,000` 的数据，二分查找约 `20` 次操作，而跳跃查找约 `1000` 次。

2.  **逻辑不够优雅**:

      * 二分查找的 `while` 循环结束后，`left` 指针**天然地**就停在了正确的插入位置上，用一套逻辑同时解决了“找到”和“找不到”两种情况。
      * 跳跃查找需要“跳跃”和“行走”两个阶段，逻辑相对割裂，不如二分查找来得直接和优雅。

> **结论**：在常规的算法题和工程实践中，只要你面对一个**有序数组**，并且时间复杂度要求是 **$O(\\log n)$**，那么**二分查找**几乎是你唯一的、也是最佳的选择。

-----

## 4\. 总结与沉淀卡片

### 📝 算法沉淀卡片：跳跃查找 (Jump Search)

  - **核心思想**: 一种在**有序数组**中进行的查找算法，它结合了**固定步长的跳跃**来快速缩小范围，和**小范围内的线性扫描**来精确定位。

  - **关键技巧**:

    1.  **分块思想**: 将有序数组逻辑上分成多个大小为 `√n` 的块。
    2.  **两阶段查找**: 先通过跳跃找到目标元素所在的**块**，再在该块内进行线性查找。

  - **复杂度分析**:

      - **时间复杂度**: $O(\\sqrt{n})$
      - **空间复杂度**: $O(1)$

  - **特点总结**:

      - **优点**:
          - 比线性查找 $O(n)$ 快。
          - 实现相对简单，内存访问模式是单向的。
      - **缺点**:
          - 比二分查找 $O(\\log n)$ 慢。
          - 同样要求数组必须有序。
      - **适用场景**: 更多地是作为一种理论模型，用于理解 $O(n)$ 和 $O(\\log n)$ 之间的算法。在实际应用中，除非有特殊的硬件限制，否则二分查找通常是更好的选择。

<!-- end list -->

```
```
