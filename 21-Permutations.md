好的，我们这就把“全排列”这个回溯算法的经典应用，连同我们讨论过的所有细节和类比，完整地沉淀下来。

这篇笔记会以“**选举**”的类比为核心，因为它能非常清晰地解释 `path`（提名名单）和 `used`（签到表）这两个关键状态的作用。

**文件名建议**：`Algorithm-Backtracking-Permutations.md`

-----

````markdown
# 经典回溯问题：全排列 (Permutations) - 学习沉淀

“全排列”问题是学习**回溯 (Backtracking)** 算法思想的绝佳范例。它要求我们找出给定的一组不含重复数字的元素的所有可能的排列顺序。这个问题完美地展示了回溯算法是如何系统性地、不重不漏地探索所有可能解的。

## 1. 核心思想：严谨的“社团干部选举”

> **故事背景：一场严谨的社团干部选举**
> -   **候选人名单 (`nums`)**: 所有可供选择的候选人，如 `{1, 2, 3}`。
> -   **你 (主 `permute` 方法)**: 选举的总负责人。
> -   **临时提名名单 (`path`)**: 你正在构建的一个候选方案，比如“主席是1，副主席是2...”。
> -   **签到表 (`used`)**: 用来记录哪些候选人已经被“提名”进入了当前的 `path`，防止重复提名。
> -   **最终公示板 (`result`)**: 用来张贴所有最终确定的、合法的干部排列方案。

**回溯的策略**：
你像一个总负责人，启动选举后，就将任务委托给了下属。每一层级的负责人都遵循着同一套严谨的流程：
1.  **为下一个空缺职位，考察所有候选人** (`for` 循环)。
2.  在考察候选人 `i` 时，先**查阅“签到表”**，如果他已被提名，就跳过。
3.  **做出选择 (Choose)**: 如果未被提名，就将他加入“临时提名名单” `path`，并在“签到表” `used` 上做标记。
4.  **向下探索 (Explore)**: 把更新后的名单和签到表，交给**更下一级的负责人**，让他去安排剩下的职位（递归调用）。
5.  **撤销选择 (Backtrack)**: 当下属负责人完成他的**所有**探索并返回后，你必须**“恢复现场”**。把刚才加入 `path` 的那个人名**擦掉**，并在 `used` 签到表上**取消标记**。这样，才能公平地进行对下一个候选人的考察。

## 2. Java 代码实现（附详细注释）

### `permute` 方法 (总负责人)
这是程序的入口，负责初始化“公示板”、“提名名单”、“签到表”，并发起第一次回溯调用。
```java
public List<List<Integer>> permute(int[] nums) {
    // 最终公示板
    List<List<Integer>> result = new ArrayList<>();
    if (nums == null || nums.length == 0) {
        return result;
    }
    
    // 临时提名名单
    List<Integer> path = new ArrayList<>();
    // 签到表
    boolean[] used = new boolean[nums.length];
    
    // 启动选举
    backtrack(nums, result, path, used);
    return result;
}
````

### `backtrack` 方法 (各级负责人)

这是递归和回溯的核心，是那个不断“**选择 -\> 探索 -\> 撤销**”的执行者。

```java
private void backtrack(int[] nums, List<List<Integer>> result, List<Integer> path, boolean[] used) {
    // 终止条件：当“提名名单”的人数等于候选人总数时，一个完整方案诞生
    if (path.size() == nums.length) {
        // 【关键】：必须 new 一个新的 List，为当前 path 拍下“快照”并存入公示板
        result.add(new ArrayList<>(path));
        return;
    }
    
    // 在所有候选人中，为下一个职位做选择
    for (int i = 0; i < nums.length; i++) {
        // 剪枝：如果这位候选人已经在当前提名名单里了，就跳过
        if (used[i]) {
            continue;
        }
        
        // --- 回溯三部曲 ---
        
        // 1. 做出选择
        path.add(nums[i]); // 将候选人加入提名名单
        used[i] = true;    // 在签到表上做标记
        
        // 2. 向下探索
        // 委托下属，去解决“在剩下的人里，如何安排剩下职位”的子问题
        backtrack(nums, result, path, used);
        
        // 3. 撤销选择 (Backtrack)
        // 当下属探索完所有可能性返回后，必须恢复现场
        path.remove(path.size() - 1); // 从提名名单末尾移除
        used[i] = false;              // 从签到表上取消标记
    }
}
```

-----

## 3\. 总结与沉淀卡片

### 📝 算法沉淀卡片：全排列 (回溯法)

  - **题号与标题**: [46. 全排列 (Permutations)](https://leetcode.cn/problems/permutations/)

  - **核心思想**: **回溯法 (Backtracking)**。通过深度优先搜索 (DFS) 的方式，系统性地探索一棵“决策树”。树的每一层代表一个位置，树的每个分支代表在该位置上选择一个可用的元素。

  - **关键技巧**:

    1.  **`used` 数组**：这是解决“排列”问题（元素不可重复使用）的关键。通过一个布尔数组来标记每个元素在当前递归路径下的使用状态，从而实现有效的“剪枝”，避免产生 `[1, 1, 2]` 这样的无效排列。
    2.  **`path` 列表**：用来记录从根节点到当前节点的路径，即一个正在构建中的排列。
    3.  **“选择-探索-撤销”三部曲**:
          - **选择**: 将元素加入 `path`，并更新 `used` 数组。
          - **探索**: 带着新的 `path` 和 `used` 状态，递归调用自身。
          - **撤销**: **（回溯的精髓）** 递归调用返回后，必须将 `path` 和 `used` 恢复到进入递归之前的状态，以便 `for` 循环能够正确地探索其他分支。
    4.  **结果拷贝**: 在找到一个完整解（满足终止条件）时，必须 `result.add(new ArrayList<>(path));` 来添加 `path` 的一个**深拷贝**，而不是直接添加 `path` 本身。

  - **复杂度分析**: (`n` = 数组元素数量)

      - **时间复杂度**: $O(n \\cdot n\!)$。共有 $n\!$ 种排列，每种排列需要 $O(n)$ 的时间来构造和添加到结果集中。
      - **空间复杂度**: $O(n)$。主要消耗在递归调用栈的深度（最多为 `n`）以及 `path` 和 `used` 数组所占的空间。

  - **同类题型**:

      - [LeetCode 78. 子集](https://leetcode.cn/problems/subsets/): 另一道经典回溯题，思考一下它的 `for` 循环和“全排列”有什么不同，为什么它不需要 `used` 数组。
      - [LeetCode 39. 组合总和](https://leetcode.cn/problems/combination-sum/): 回溯法的变体，元素可以重复使用，且需要考虑加和的目标值。

<!-- end list -->

```
```
