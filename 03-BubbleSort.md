# 📝 排序算法基础：冒泡排序 (Bubble Sort)

## 核心思想

> 冒泡排序的核心思想是**“逐对比较，按需交换”**。它像水中的气泡一样，在每一轮的比较中，将当前未排序部分的最大（或最小）值，通过**相邻元素之间的交换**，一步步地“冒泡”到序列的末端。

## 算法步骤 (以升序为例)

1.  **外层循环（轮数）**: 从头开始，进行第一轮“冒泡”。
2.  **内层循环（比较）**: 在这一轮中，从第一个元素开始，依次比较**每一对相邻**的元素 (`arr[j]` 和 `arr[j+1]`)。
3.  **比较与交换**: 如果前者比后者大，就交换它们的位置。
4.  **一轮结束**: 当内层循环走完一遍后，当前未排序部分的最大值必然已经“冒泡”到了本轮的终点。
5.  **重复**: 重复执行外层循环，每一轮都将处理范围缩小1（因为末尾的元素已经就位），直到所有元素都有序。

---

## 代码实现 (标准版)

这是冒泡排序最常见、最规范的写法，建议以此为标准。

```java
public class BubbleSort {

    public static void sort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        int n = arr.length;
        // 外层循环控制总共需要进行 n-1 轮冒泡
        for (int i = 0; i < n - 1; i++) {
            // 内层循环负责在每一轮中进行相邻元素的比较
            // -i 是因为每轮过后，末尾就有 i 个元素已经排好序，无需再比较
            for (int j = 0; j < n - 1 - i; j++) {
                // 比较相邻的两个元素
                if (arr[j] > arr[j + 1]) {
                    // 如果前者大于后者，则交换
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }

    public static void main(String[] args) {
        int[] nums = {2, 5, 8, 4, 3};
        sort(nums);
        System.out.println("排序之后的数组为：");
        // 打印结果...
    }
}
````

-----

## 关键错误警示：我的思考误区

这是在学习过程中非常宝贵的经验，记录下来，可以有效避免重蹈覆辙。

### 误区一：比较“固定参照物”而非“相邻元素”

最开始，我尝试用外层循环的 `arr[i]` 去和内层循环的 `arr[j]` 比较。

**错误代码示例**:

```java
// 错误逻辑
if (arr[i] > arr[j]) {
    // ...
}
```

**警示**：这种写法混淆了冒泡排序和选择排序。冒泡排序的灵魂在于\*\*“只和邻居比”\*\* (`arr[j]` vs `arr[j+1]`)，它是一种局部比较的策略。而用一个固定的 `arr[i]` 去和所有后续元素比较，是在试图“选出”一个极值，这是选择排序的思想，两者混用会导致逻辑错乱。

### 误区二：“差一错误”——循环边界提前终止

在意识到要比较相邻元素后，我写出了 `arr[j-1] > arr[j]` 的逻辑，但内层循环的边界写错了。

**错误代码示例**:

```java
// 循环边界错误
for (int j = 1; j < arr.length - 1 - i; j++) {
    if (arr[j - 1] > arr[j]) {
        // ...
    }
}
```

**警示**：这个循环条件 `j < arr.length - 1 - i` 导致每一轮都**遗漏了最后一对元素的比较**，使得最大值无法真正“沉底”。

> **核心调试秘訣**：当排序结果不符合预期时，**优先怀疑循环边界**。拿一个最短的例子（3-4个元素），在纸上“人肉调试”，追踪 `i` 和 `j` 的每一个值，问题将无所遁形。正确的边界应该是 `j < arr.length - i` (当`j`从1开始) 或 `j < arr.length - 1 - i` (当`j`从0开始)。

-----

## 拓展细节：性能优化

标准的冒泡排序无论数组初始状况如何，都会执行完所有循环。但如果某一轮下来，我们发现一次交换都没发生，就说明数组已经完全有序了，可以提前终止。

### 更智能的冒泡排序 (代码实现)

```java
public static void sortOptimized(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    int n = arr.length;
    for (int i = 0; i < n - 1; i++) {
        // 设立一个标志位，假设本轮没有发生交换
        boolean didSwap = false; 
        for (int j = 0; j < n - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                // 如果发生了交换，将标志位置为 true
                didSwap = true; 
            }
        }
        // 如果本轮循环结束，标志位依然是 false，说明数组已有序，直接退出
        if (!didSwap) {
            break;
        }
    }
}
```

-----

## 性能分析

  - **时间复杂度 (Time Complexity)**:
      - **最坏情况**: $O(N^2)$ (数组完全逆序)
      - **平均情况**: $O(N^2)$
      - **最好情况**: $O(N)$ (使用优化标志位，数组已经有序)
  - **空间复杂度 (Space Complexity)**:
      - $O(1)$ (只需要一个 `temp` 变量用于交换，是**原地排序**算法)
  - **稳定性 (Stability)**:
      - **稳定** (在比较 `arr[j] > arr[j+1]` 时，如果值相等，不会发生交换，保证了相等元素的相对顺序不变)

## 总结

冒泡排序因其 $O(N^2)$ 的时间复杂度，在实际工程中**几乎不被使用**。但它逻辑简单，是理解排序算法思想、原地排序、稳定性等核心概念的绝佳入门教材。

```
```
