# 📝 排序算法核心概念：原地排序 (In-place Sort)

## 核心思想

> 原地排序的核心思想是**节省空间**。它指算法在执行过程中，所占用的额外（辅助）存储空间不随输入数据规模的增长而增长，通常是常数级 `O(1)` 或对数级 `O(log N)`。

## 关键判断标准

判断一个算法是否为“原地”的唯一标准是看其**空间复杂度 (Space Complexity)**。

- **原地 (In-place)**: 空间复杂度为 `O(1)` 或 `O(\log N)`。
- **非原地 (Out-of-place)**: 空间复杂度为 `O(N)` 或更高（即需要一个与输入规模成正比的额外空间）。

---

## 一个绝佳的类比：整理书架

为了直观地理解，想象一下整理书架上的书：

-   **原地排序 (In-place)**:
    你**只有一个书架**。你只能在这个书架内部来回挪动、交换书籍的位置来整理它们。你手上最多只能同时拿着一两本书（这代表了 `O(1)` 的临时变量）。你的工作空间就是书架本身，几乎不需要额外的场地。

-   **非原地排序 (Out-of-place)**:
    你旁边还有一个**同样大小的空书架**。你从乱的书架上，按顺序一本本挑出来，直接放到那个**新的空书架**上。完成时，你占用了一共两倍的书架空间。这个“新的空书架”就是 `O(N)` 的额外空间。

---

## 常见算法归属

了解哪些是原地排序，有助于你在需要考虑内存限制时做出正确的技术选型。

-   ✅ **属于原地排序 (空间效率高)**:
    -   **快速排序 (Quick Sort)**: 空间复杂度为 `O(\log N)`，用于递归栈，通常被认为是原地排序。
    -   **堆排序 (Heap Sort)**: 空间复杂度为 `O(1)`。
    -   **插入排序 (Insertion Sort)**: 空间复杂度为 `O(1)`。
    -   **冒泡排序 (Bubble Sort)**: 空间复杂度为 `O(1)`。
    -   **选择排序 (Selection Sort)**: 空间复杂度为 `O(1)`。

-   ❌ **不属于原地排序 (空间开销大)**:
    -   **归并排序 (Merge Sort)**: 需要一个 `O(N)` 的临时数组来辅助合并操作。
    -   **计数排序 (Counting Sort)**: 需要一个 `O(k)` 的计数桶（`k` 是数据范围）。
    -   **桶排序 (Bucket Sort)**: 需要 `O(N)` 的桶空间。

---

## 重要澄清：与“稳定性”完全无关

这是最容易出错的地方，必须明确：

> “原地”和“稳定”是描述排序算法的两个**完全独立、互不相干**的维度。

-   `原地排序` 只关心**空间开销**。
-   `稳定排序` 只关心**相等元素的相对顺序**。

一个算法可以是**原地的且稳定的**（如插入排序），也可以是**原地的但不稳定的**（如快速排序）。绝对不能用一个属性去推断另一个。

## `List.sort()` 的情况回顾

Java 的 `List.sort()`（底层为 TimSort）是一个需要特别理解的特例：

-   从**使用者视角**看：它直接修改了你传入的那个 List，没有返回一个新的 List，所以它的**行为表现**是“原地”的。
-   从**算法实现视角**看：它为了追求极致的效率，在合并数据时**会申请额外的内存空间**（最坏情况下接近 `O(N)`），所以它**不是一个严格意义上的原地排序算法**。
