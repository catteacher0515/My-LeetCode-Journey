# 排序算法：归并排序 (Merge Sort) - 学习沉淀

归并排序是“分而治之”思想的经典体现。其核心哲学是“先拆分，后合并”：先通过递归，将一个大问题无脑地拆解成最简单的小问题；然后，在回溯的过程中，再将小问题的答案一步步地合并，最终解决整个大问题。

---

## 1. `mergeSort` 方法：拆分任务的“总指挥”

这个方法是递归的入口，扮演着“总指挥”的角色，其唯一的任务就是**不断地将一个大数组从中间一分为二**，直到每个子数组只剩下一个元素。

> **你的理解：**
> > 这部分主要负责分治，把原数组拆分到最小子单元。不断地寻找中间点的过程其实就是递归的过程。

### 代码实现
```java
public static void mergeSort(int[] arr, int left, int right) {
    // 只有当子数组至少有两个元素时，才需要继续拆分
    if (left < right) {
        // 找出中间点
        int mid = left + (right - left) / 2;

        // 递归排序左右两半 (继续下达拆分指令)
        mergeSort(arr, left, mid);       // 左侧
        mergeSort(arr, mid + 1, right);  // 右侧

        // 当左右两半都已各自有序后，调用专家进行合并
        merge(arr, left, mid, right);
    }
}
````

### 关键点解析

#### **中间点的计算：`mid`**

`int mid = left + (right - left) / 2;`

> **你的理解：**
>
> > 中间点为什么这么写？ `left + (right - left) / 2` 可以防止在处理超大数组时 `left + right` 造成整数溢出。
>
> > **第一轮** (数组有8个元素, `left = 0; right = 7`):
> > `mid = 0 + (7 - 0) / 2 = 3` (下标3，即第4个元素)
>
> > **第二轮 (左侧)** (数组有4个元素, `left = 0; right = 3`):
> > `mid = 0 + (3 - 0) / 2 = 1`
>
> > **第二轮 (右侧)** (数组有4个元素, `left = 4; right = 7`):
> > `mid = 4 + (7 - 4) / 2 = 5`
>
> > 确实是应该这么算。

#### **递归的边界**

> **你的理解：**
>
> > 至于在递归的时候：
>
> >   - 左侧分组: `left` 不变, `right` 变为 `mid`
> >   - 右侧分组: `right` 不变, `left` 变为 `mid+1`

-----

## 2\. `merge` 方法：合并有序的“专家”

当递归拆分到最底层，并开始回溯时，`merge` 方法就登场了。它是一个“合并专家”，专门负责将**两个已经有序的子数组**，合并成一个更大的有序数组。

### 代码实现

```java
private static void merge(int[] arr, int left, int mid, int right) {
    // 步骤1：计算子数组大小并创建临时数组
    int n1 = mid - left + 1;
    int n2 = right - mid;
    int[] L = new int[n1];
    int[] R = new int[n2];

    // 步骤2：将数据复制到临时数组
    for (int i = 0; i < n1; i++)
        L[i] = arr[left + i];
    for (int j = 0; j < n2; j++)
        R[j] = arr[mid + 1 + j];

    // 步骤3：合并核心
    int i = 0, j = 0;
    int k = left;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    // 步骤4：处理剩余元素
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}
```

### 关键点解析

#### **计算子数组大小**

> **你的类比：**
>
> > 可以理解为一个书籍翻页的问题，从第 a 页翻到第 b 页翻了多少页。
>
> **补充修正**：你这个类比非常棒！计算闭区间 `[a, b]` 内的元素个数，正确的公式是 `b - a + 1`。
>
>   - 左侧数组的个数 (`n1`)，范围是 `[left, mid]`，所以个数是 `mid - left + 1`。
>   - 右侧数组的个数 (`n2`)，范围是 `[mid + 1, right]`，所以个数是 `right - (mid + 1) + 1`，化简后就是 `right - mid`。
>     你的代码是完全正确的！

#### **复制数据**

> **你的记忆方法：**
>
> > 我觉得“本地指针”和“全局指针”这个记忆想法就已经足够好了。
>
> >   - **左侧**：本地指针从 `i=0` 开始，全局指针从 `left` 开始，合计起来 `arr[left + i]`。
> >   - **右侧**：本地指针从 `j=0` 开始，全局指针从 `mid + 1` 开始，合计起来 `arr[mid + 1 + j]`。

#### **合并核心**

> **你的角色扮演：**
>
> >   - `i` 裁判负责盯着 L 数组, `j` 裁判负责盯着 R 数组。
> >   - `k` 的任务是，指向原始大数组 `arr` 中，下一个应该被填充的正确位置，它自然从 `left` 开始。
>
> **你的逻辑理解：**
>
> >   - `while (i < n1 && j < n2)`：有任意一方的元素比较完毕就结束。
> >   - 无论录取谁, `k` 都是一定要 `+1` 的。
> >   - 录取到的那一队也正常的 `+1`, 来比较下一位成员，另一队保持不变。

#### **收尾工作**

> **你的理解（“剩菜”理论）：**
>
> >   - 这些“剩下来”的元素有什么特点？
> >   - 它们本身是有序的。
> >   - 它们都大于我们已经合并到 `arr` 里的所有元素。
> >   - 有剩余的就直接排到花名册的后面就好。

-----

## 3\. 归并排序特点总结

  - **时间复杂度**: **$O(n \\log n)$**。性能非常稳定，不受输入数据的影响。
  - **空间复杂度**: **$O(n)$**。需要创建临时的子数组来辅助合并，这是它的主要缺点。
  - **稳定性**: **稳定 (Stable)**。在合并时，`if (L[i] <= R[j])` 保证了相等元素的原始相对顺序不被改变。

<!-- end list -->

```
```
