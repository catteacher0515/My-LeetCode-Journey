# 📝 LeetCode 沉淀卡片 - 283. 移动零 (最终版)

## 题目描述 (Problem Description)

给定一个整数数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**约束条件**:
1.  必须在原数组上操作，不能拷贝额外的数组（**原地算法**）。
2.  尽量减少操作次数。

**示例**:
- **输入**: `nums = [0, 1, 0, 3, 12]`
- **输出**: `[1, 3, 12, 0, 0]`

---

## 核心痛点与思路转变 (Core Pain Point & Mindset Shift)

> 最开始想用“冒泡排序”的思路，让 `0` 一步步换到最后，但很快发现，一个 `0` 每次只能移动一格，效率太低 ($O(N^2)$)，而且非零的数也被不必要地来回移动。
>
> **真正的思路转变在于：我不应该关心怎么“移动0”，我应该只关心怎么“安置非零数”**。只要所有非零数都按顺序被“迁移”到数组的最前面，剩下的位置自然就全是 `0` 了。

---

## 解法诀竅 (The Trick)

> **单指针覆盖 + 补零**。这个技巧可以想象成**“整理房间”**：
>
> 1.  **准备一个“干净区”的边界指针 `k`** (或者叫 `insertPos`)，它始终指向下一个“宝贝”（非零数）应该被放的位置。初始时，整个房间都是“待整理区”，所以 `k = 0`。
>
> 2.  **开始“打扫”**：从头到尾遍历整个房间（数组 `i` 从 `0` 到 `n-1`）。
>
> 3.  **遇到“宝贝”就往前放**：一旦发现一个非零数 `nums[i]`，二话不说，直接把它放到“干净区”的边界 `nums[k]` 上，然后把干净区的边界扩大一格（`k++`）。
>
> 4.  **第一遍打扫完毕**：遍历结束后，`[0, k-1]` 这个区间，就全是我们按顺序捡回来的“宝贝”（非零数）了。
>
> 5.  **“垃圾”归位**：最后，从 `k` 的位置开始，把房间剩下的所有空间（`[k, n-1]`）全部用“垃圾”（`0`）填满。

---

## 最优解代码 (Optimal Solution Code)

```java
class Solution {
    public void moveZeroes(int[] nums) {
        // 边界条件判断
        if (nums == null || nums.length == 0) {
            return;
        }

        // k 指针始终指向下一个非零元素应该被放置的位置
        int k = 0;

        // 第一次遍历：将所有非零元素，按顺序覆盖到数组前面
        for (int i = 0; i < nums.length; i++) {
            // 如果当前元素不是 0
            if (nums[i] != 0) {
                // 将其放置在 k 的位置
                // 如果 k 和 i 相同，这里就是自己给自己赋值，可以优化，但为了逻辑清晰暂不优化
                nums[k] = nums[i];
                // k 指针前进，为下一个非零元素准备位置
                k++;
            }
        }

        // 第二次遍历：将 k 之后的所有位置填充为 0
        for (int i = k; i < nums.length; i++) {
            nums[i] = 0;
        }
    }
}
````

-----

## 复杂度分析

  - **我的解法 (冒泡思路)**: Time $O(N^2)$ (因为嵌套循环，每个0都要一步步移动), Space $O(1)$
  - **最优解法 (覆盖补零)**: Time $O(N)$ (**因为数组中的每个元素只被访问和操作常数次**), Space $O(1)$

-----

## 易错点与反思

  - **最大的陷阱是把问题当成“排序”**。一旦陷入排序的思维定式，就很难想到 $O(N)$ 的解法。这是一个原地\*\*“压缩”**或**“整理”\*\*的问题。
  - **边界条件的坑**：`if (nums[0] == 0)` 这种判断是错误的，它会漏掉 `[0, 1]` 这样的重要测试用例。要相信你的算法能处理所有情况，而不是用特例去限制它。
  - **最优解的核心是忽略 `0`**。在第一遍遍历中，我们对 `0` 的处理方式就是“无视”，这大大减少了不必要的判断和数组写入操作。

-----

## 同类题型

  - [27. 移除元素 (Remove Element)](https://leetcode.cn/problems/remove-element/): 思路完全一样，把“非零数”当成“宝贝”，“指定值”当成“垃圾”即可。
  - [26. 删除有序数组中的重复项 (Remove Duplicates from Sorted Array)](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/): 同样是“原地修改”+“快慢指针”的经典应用。

<!-- end list -->

```
```
