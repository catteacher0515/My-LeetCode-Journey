# Java 代码反思：从一次数组计数的错误中学习

> 每一次代码的报错，都是一次深入理解语言和逻辑的绝佳机会。本文记录了在解决 LeetCode "有多少小于当前数字的数字" 问题时犯下的一个典型错误，并从中提炼出值得注意的编程原则。

## 1. 问题背景

**问题描述：** 给定一个整数数组 `nums`，对于数组中的每个元素 `nums[i]`，需要找出数组中到底有多少个其他数字比它小。最后，返回一个新数组记录这些计数结果。

例如，输入 `nums = [8, 1, 2, 2, 3]`，应返回 `[4, 0, 1, 1, 2]`。

## 2. 我的初始代码（错误版本）

这是我最开始基于“暴力解法”思路写下的代码，它包含了一个致命的语法错误和一处逻辑冗余。

```java
class Solution {
    public static int[] smallerNumbersThanCurrent(int[] nums) {
        // 这个题感觉不需要进行排序了哈
        // 直接遍历数组进行比较就可以了
        // 新建一个数组来存储,再一切准备就绪之后再通过循环复制
        int[] arr = new int[nums.length];

        // 还是先对新数组进行赋值吧
        for(int i = 0; i < nums.length; i++){
            arr[i] = 0;
        }

        for(int i = 0; i < nums.length; i++){
            for(int j = 0; j < nums.length; j++){
                if(nums[i] > nums[j] && j != i){
                    arr[i]++;
                }
            }
        }
        // !!! 此处存在语法错误 !!!
        return int[] arr;
    }
}
```

## 3. 问题剖析与修正

### 错误一：致命的语法错误

* **错误代码：** `return int[] arr;`
* **问题本质：** 混淆了 **“变量声明”** 和 **“变量返回”** 的语法。
    * **声明 (Declaration):** `int[] arr = new int[nums.length];` 是在告诉编译器：“我要创建一个名为 `arr` 的变量，它的类型是整型数组”。此时需要指定类型。
    * **返回 (Return):** `return arr;` 是在告诉方法：“请把已经存在的，名为 `arr` 的这个变量的值交出去”。此时变量已经存在，它的类型是确定的，直接使用它的名字即可。
* **正确修正：**
    ```java
    return arr;
    ```
* **核心原则：** **一个萝卜一个坑。** 声明变量是给变量“挖坑”，需要说明坑的类型；返回变量是把坑里的“萝卜”交出去，直接交萝卜就行，不用再告诉别人这是个萝卜。

### 错误二：不必要的逻辑冗余

* **冗余代码：**
    ```java
    for(int i = 0; i < nums.length; i++){
        arr[i] = 0;
    }
    ```
* **问题本质：** 对语言的底层特性不熟悉。
    * 在 Java 中，当你使用 `new int[size]` 创建一个基本类型的数组时，JVM 会为其分配内存，并自动将所有元素**初始化为该类型的默认值**。对于 `int` 类型，这个默认值就是 `0`。
* **代码优化：** 直接删除这个循环。代码不仅更短，而且更能体现出你对语言的了解。
* **核心原则：** **不要重复造轮子，尤其是语言已经帮你造好的轮子。** 了解并利用语言的内置特性，是写出地道、简洁、高效代码的基础。

## 4. 修正与重构后的代码

综合以上两点进行修正后，得到一个逻辑正确且风格更专业的版本。

```java
class Solution {
    /**
     * 计算数组中每个元素有多少个比它小的数字（暴力解法）。
     * 时间复杂度: O(N^2)
     * 空间复杂度: O(N)
     */
    public static int[] smallerNumbersThanCurrent(int[] nums) {
        // 1. 创建结果数组。Java 会自动将其所有元素初始化为 0。
        int[] result = new int[nums.length];

        // 2. 使用两层循环进行暴力比较。
        for (int i = 0; i < nums.length; i++) {
            for (int j = 0; j < nums.length; j++) {
                // 3. 如果 nums[i] 大于 nums[j]，则计数器加一。
                // (注意：i == j 的情况 nums[i] > nums[j] 不成立，所以 j != i 的判断是可选的)
                if (nums[i] > nums[j]) {
                    result[i]++;
                }
            }
        }

        // 4. 返回最终的结果数组。
        return result;
    }
}
```

## 5. 沉淀与反思

这次简单的代码调试，带来了几个重要的收获：

1.  **语法是地基，必须绝对精确：** 逻辑想得再好，语法错了程序连运行的机会都没有。对基础语法的熟练和精确是第一位的。
2.  **理解语言特性是“入门”与“熟练”的分水岭：** 知道 `new int[]` 默认是 `0`，让你写出的代码比别人更简洁、更地道。这是从“能用”到“好用”的转变。
3.  **永远为效率留一扇窗：** 当前的 $O(N^2)$ 解法虽然直观，但在数据量大时会很慢。解决问题后，应该多问自己一句：“有没有更好的方法？” 这会引导你去思考排序、哈希表等更高效的算法，从而打开新世界的大门。

把错误变成垫脚石，而不是绊脚石。记录下来，时常回顾，这就是最扎实的进步。
````
