好的，你说得对。我们刚才沉淀的是那道 LeetCode 题目的**具体解法**，现在我们来把“汉诺塔”这个**算法思想本身**，进行一次更通用、更深刻的沉淀。

**文件名建议**：`Algorithm-Classic-Recursion-Tower-of-Hanoi.md`

-----

````markdown
# 经典递归问题：汉诺塔 (Tower of Hanoi)

汉诺塔是学习和理解**递归 (Recursion)** 思想的终极“道场”。它的代码极其简短，但背后蕴含的“分而治之”和“抽象”的思维方式非常深刻。

## 1. 核心思想：信任递归的“信仰之跃”

解决汉诺塔问题的关键，不在于人脑去模拟 `n` 个圆盘每一步的具体移动（这会极其复杂），而在于将一个大问题，拆解成结构完全一样、但规模更小的子问题，并**信任**我们正在写的函数已经具备解决子问题的超能力。

这个过程就像一个“懒惰但聪明的国王”：他从不亲自解决整个问题，他只把问题拆分，然后委托给能力和他一样的“将军”去完成。

## 2. 汉诺塔的三步“大战略”

**总目标**：将 `n` 个圆盘，从 `源柱 (source)` 移动到 `目标柱 (target)`，可以借助 `辅助柱 (auxiliary)`。

为了移动最底下那个**最大**的 `n` 号圆盘，我们必须分三步走：

1.  **第1步 (子问题一)**: 将压在 `n` 号圆盘上面的那 `n-1` 个小圆盘，想办法从 `源柱` 移动到 `辅助柱`。
2.  **第2步 (基本问题)**: 现在 `n` 号圆盘上面空了，我们可以直接把它从 `源柱` 移动到 `目标柱`。
3.  **第3步 (子问题二)**: 最后，再把放在 `辅助柱` 上的那 `n-1` 个小圆盘，想办法移动到 `目标柱`。

这个“三步走”的战略，就是递归算法的全部逻辑。

## 3. 经典 Java 代码实现 (打印移动步骤)

这份代码是汉诺塔算法最纯粹的逻辑体现。

```java
public class TowerOfHanoi {
    /**
     * 解决汉诺塔问题的递归函数
     * @param n          要移动的盘子数量
     * @param source     源柱 (starting rod)
     * @param auxiliary  辅助柱 (auxiliary rod)
     * @param target     目标柱 (target rod)
     */
    public static void solveHanoi(int n, char source, char auxiliary, char target) {
        // 基准情况 (Base Case)：如果要移动的盘子只剩下 1 个
        if (n == 1) {
            // 直接移动并打印步骤，递归终止
            System.out.println("移动圆盘 1 从 " + source + " 到 " + target);
            return;
        }
        
        // 递归步骤 (Recursive Step)

        // 战略第1步：将 n-1 个盘子从 source 移动到 auxiliary。
        // 在这个子任务中，原来的 target 柱变成了“临时辅助柱”。
        solveHanoi(n - 1, source, target, auxiliary);
        
        // 战略第2步：移动最底下的第 n 个盘子。
        System.out.println("移动圆盘 " + n + " 从 " + source + " 到 " + target);
        
        // 战略第3步：将 n-1 个盘子从 auxiliary 移动到 target。
        // 在这个子任务中，原来的 source 柱变成了“临时辅助柱”。
        solveHanoi(n - 1, auxiliary, source, target);
    }
}
````

### 关键点解析

  - **基准情况 (Base Case)**: `n == 1` 是递归的“刹车”，它定义了最小的可解问题。没有它，递归将无限进行。
  - **参数交换**: 递归调用的精髓在于**参数角色的互换**。在解决子问题时，原来的“目标柱”和“辅助柱”的角色会根据任务需求灵活地交换，这正是其巧妙之处。

-----

## 4\. 总结与沉淀卡片

### 📝 算法沉淀卡片：汉诺塔 (Tower of Hanoi)

  - **核心思想**: 一个经典的**分而治之 (Divide and Conquer)** 问题。将“移动n个盘子”的复杂任务，分解为“移动n-1个盘子”的两个子任务和一个“移动1个盘子”的基本任务。

  - **关键技巧**: **递归 (Recursion)**。
    算法的定义和实现高度统一。函数通过调用自身来解决规模更小的、结构相同的问题，并通过巧妙地交换 `source`, `auxiliary`, `target` 参数的角色来完成复杂的移动逻辑。解决这类问题的核心是“**递归的信仰之跃**”——相信函数自身已经能够解决子问题。

  - **复杂度分析**: (`n` = 盘子数量)

      - **时间复杂度**: $O(2^n)$。移动 `n` 个盘子需要 $2^n - 1$ 次操作。每次函数调用都会分裂成两次递归调用，形成指数级增长，效率极低。
      - **空间复杂度**: $O(n)$。空间主要消耗在递归调用栈上，最大深度为 `n`。

  - **相关核心概念**:

      - **分而治之 (Divide and Conquer)**: 算法设计范式。
      - **递归 (Recursion)**: 具体的实现技术。
      - **调用栈 (Call Stack)**: 理解递归背后内存机制的关键。

<!-- end list -->

```
```
