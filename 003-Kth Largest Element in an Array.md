# 📝 LeetCode 沉淀卡片 - 215. 数组中的第K个最大元素

## 题目描述 (Problem Description)

给定一个整数数组 `nums` 和一个整数 `k`，请找出数组中排序后的第 `k` 个最大的元素。

**注意**：你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

**示例**:
- **输入**: `nums = [3, 2, 1, 5, 6, 4]`, `k = 2`
- **输出**: `5` (因为排序后数组为 `[6, 5, 4, 3, 2, 1]`，第2大的元素是 `5`)

---

## 我的解法分析 (Analysis of My Solution)

**思路与优点**:
你的目标非常明确：为了巩固知识，使用选择排序。你正确地识别出，只要将数组**从大到小**完整排序，那么第 `k` 大的元素就是索引为 `k-1` 的那个。你还记住了选择排序“打擂台”和内层循环 `j = i + 1` 的核心结构，这非常好。

**核心错误：错误的“打擂台”方式**
你的代码虽然有选择排序的框架，但在最关键的步骤上出现了偏差。

**你的错误代码**:
```java
// 在内层循环中
if(nums[j] > nums[maxindex]){
    // 错误点：一旦发现更强者，立刻就进行了交换
    int temp = nums[maxindex];
    nums[maxindex] = nums[j];
    nums[j] = temp;
}
````

**问题分析**:
真正的选择排序，其精髓在于\*\*“选”**和**“换”\*\*是完全分离的两个步骤。

  - **“选”**: 内层循环 (`j` 循环) 的**唯一**目的，是**只看不换**。它需要走遍所有“挑战者”，仅仅是**找出并记录**那个最强擂主（最大值）的**位置 `maxIndex`**。
  - **“换”**: **交换**动作，必须在内层循环**完全结束之后**，在 `i` 循环中，**只执行唯一的一次**。

**你的代码做了什么？**
你的代码在内层循环中，**每发现一个比当前 `maxIndex` 所在位置更强的挑战者，就立刻进行了交换**。这破坏了选择排序的逻辑。

**用“打擂台”的类比来说**：

> 这相当于，擂台上打到一半，裁判发现一个新人B比当前的擂主A更厉害，于是立刻暂停比赛，把A踢下台，让B站到擂主的位置上，然后让B接着接受后面其他人的挑战。这会让整个比赛的参照物不断变化，最终结果就会乱套。
>
> **正确的流程应该是**：让所有挑战者都和当前的擂主A比试一遍，裁判心里默默记下最强的那个人是谁（比如是Z），等所有人都比完了，再宣布：“本轮总冠军是Z！”，然后把Z请到冠军宝座（`i` 位置）上。

**正确的选择排序实现 (降序)**:

```java
public void selectionSortDescending(int[] nums) {
    for (int i = 0; i < nums.length - 1; i++) {
        // 1. “选”：在内层循环中只找索引，不交换
        int maxIndex = i; // 假设擂主是 i
        for (int j = i + 1; j < nums.length; j++) {
            if (nums[j] > nums[minIndex]) {
                maxIndex = j; // 更新最强者的位置
            }
        }
        // 2. “换”：内层循环结束后，进行唯一的一次交换
        if (maxIndex != i) {
            int temp = nums[i];
            nums[i] = nums[maxIndex];
            nums[maxIndex] = temp;
        }
    }
}
```

-----

## 解法一：完整排序 (基于修正后的选择排序)

**思路**: 先将整个数组按降序排好，然后直接返回第 `k` 个元素（即索引为 `k-1` 的元素）。

**代码实现**:

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        // 1. 使用选择排序（降序）将数组完整排序
        selectionSortDescending(nums);
        
        // 2. 返回第 k 大的元素
        return nums[k - 1];
    }

    private void selectionSortDescending(int[] nums) {
        for (int i = 0; i < nums.length - 1; i++) {
            int maxIndex = i;
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[j] > nums[minIndex]) {
                    maxIndex = j;
                }
            }
            if (maxIndex != i) {
                int temp = nums[i];
                nums[i] = nums[maxIndex];
                nums[maxIndex] = temp;
            }
        }
    }
}
```

  - **复杂度分析**:
      - **Time**: $O(N^2)$ - 对于此题，会**超时**。
      - **Space**: $O(1)$

-----

## 最优解法详解 (思路拓展)

解决 “Top K” 问题，我们其实不需要对整个数组进行完整排序。

### 思路一：基于快速排序的“快速选择”算法

  - **核心思想**: 我们真的需要把整个数组都排好序吗？其实不需要。我们只需要找到那个**恰好**能让 `k-1` 个元素比它大，`n-k` 个元素比它小的\*\*“分割点”(pivot)\*\* 就行了。快速排序的 `partition` 操作天生就是用来找这种分割点的。
  - **解法诀窍**:
    1.  随机选一个 `pivot`，对数组进行分区，得到 `pivot` 的最终位置 `p`。
    2.  比较 `p` 和 `k-1`：
          - 如果 `p == k-1`，恭喜，`nums[p]` 就是答案。
          - 如果 `p < k-1`，说明第 `k` 大的数在 `p` 的右边，我们只需要在**右半区**继续寻找。
          - 如果 `p > k-1`，说明第 `k` 大的数在 `p` 的左边，我们只需要在**左半区**继续寻找。
  - **复杂度分析**:
      - **Time**: 平均 $O(N)$，最坏 $O(N^2)$ (但概率极低)。
      - **Space**: $O(\\log N)$ (递归栈空间)。

### 思路二：使用小顶堆 (Min-Heap)

  - **核心思想**: 维护一个大小为 `k` 的“擂台”（小顶堆），擂台上始终是我们**目前为止见过的 `k` 个最大的元素**。而“擂主”，就是这 `k` 个人里**最弱**的那个（堆顶元素）。
  - **解法诀窍**:
    1.  创建一个大小为 `k` 的小顶堆。
    2.  遍历数组中的每个数 `n`：
          - 如果堆没满，直接把 `n` 加进去。
          - 如果堆满了，将 `n` 和堆顶（擂主）比较。如果 `n` 比擂主还强（`n > heap.peek()`），就把擂主请下台（`heap.poll()`），让 `n` 占住擂主的位置（`heap.add(n)`）。
    3.  遍历结束后，堆里剩下的就是整个数组最大的 `k` 个数，而堆顶的那个，自然就是第 `k` 大的元素。
  - **复杂度分析**:
      - **Time**: $O(N \\log k)$ (每个元素都要尝试进堆，堆操作是 `log k` 级别)。
      - **Space**: $O(k)$ (用于存储堆)。

-----

## 总结与沉淀

  - **我的练习目的**: 使用选择排序来巩固基础算法，这是一个非常好的主动学习过程。
  - **我的核心错误**: 将选择排序的\*\*“寻找最大值索引”**和**“交换”**两个步骤混在了一起。必须牢记，选择排序的精髓在于**内循环只找索引，外循环只换一次\*\*。
  - **最优思路**: 解决“Top K”问题，不一定要完整排序。**快速选择 (Quickselect)** 通过分区剪枝，是平均情况下的理论最优解。**堆 (Heap)** 提供了一个非常稳定且易于理解的 $O(N \\log k)$ 解法，在面试中同样常用。

<!-- end list -->

```
```
