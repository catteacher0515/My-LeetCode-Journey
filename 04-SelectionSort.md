# 📝 排序算法基础：选择排序 (Selection Sort)

## 核心思想：“打擂台选冠军”

> 选择排序的核心思想是**“分区”**与**“选择”**。它将数组逻辑上分为**“已排序区”**（在左侧）和**“未排序区”**（在右侧）。每一轮的目标，就是在“未排序区”中，挑选出最小（或最大）的元素，然后将它放置到“已排序区”的末尾。

## 算法步骤 (以升序为例)

1.  **划定战场**: 初始时，将整个数组视为“未排序区”。
2.  **外层循环 (选拔冠军)**: 从 `i = 0` 到 `n-2`，每一轮为第 `i` 个位置选出正确的元素。
3.  **设立临时擂主**: 在每一轮开始时，**假设**“未排序区”的第一个元素 `arr[i]` 就是最小的，记录其索引 `minIndex = i`。
4.  **内层循环 (挑战者上场)**: 让 `i` 后面的所有元素 (`j` 从 `i+1` 开始) 逐个与当前的“擂主” (`arr[minIndex]`) 进行比较。
5.  **更新擂主**: 如果发现有更小的挑战者 (`arr[j] < arr[minIndex]`)，则更新 `minIndex` 为 `j`。
6.  **冠军就位**: 内层循环结束后，`minIndex` 就是“未排序区”中最小元素的真正索引。将 `arr[i]` 和 `arr[minIndex]` 进行**交换**。
7.  **缩小战场**: `i` 增加1，“已排序区”扩大一格，“未排序区”缩小一格。重复以上步骤直到结束。

---

## 代码实现

```java
public class SelectionSort {

    public static void sort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        int n = arr.length;
        // 外层循环：控制轮数，每一轮为 arr[i] 找到正确的元素
        for (int i = 0; i < n - 1; i++) {
            // 1. 假设未排序区的第一个元素为最小，记录其索引
            int minIndex = i;

            // 2. 内层循环：在未排序区中寻找真正的最小值索引
            for (int j = i + 1; j < n; j++) {
                // 如果发现有更小的元素，则更新最小值的索引
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;
                }
            }

            // 3. 将找到的最小值与未排序区的第一个元素交换位置
            //    (如果 minIndex 没有变，就相当于自己和自己交换)
            if (minIndex != i) {
                int temp = arr[i];
                arr[i] = arr[minIndex];
                arr[minIndex] = temp;
            }
        }
    }

    public static void main(String[] args) {
        int[] nums = {5, 3, 8, 1};
        sort(nums);
        // 打印结果...
    }
}
````

-----

## 关键逻辑解析：`for(int j = i + 1; ...)`

这是选择排序的**灵魂所在**，理解了它就理解了整个算法。

  - **`i` 的作用**: 是“已排序区”和“未排序区”的**分界线**。当外层循环到达 `i` 时，意味着 `0` 到 `i-1` 的位置已经尘埃落定，放着的是整个数组最小的 `i` 个数。

  - **`minIndex = i` 的作用**: 我们的任务是在“未排序区” (`i` 到 `n-1`) 中寻找冠军。总得有个开始，所以我们**假定**该区的第一个人 `arr[i]` 就是冠军（擂主）。

  - **`j = i + 1` 的作用**: 内层循环的职责，就是让\*\*所有其他的“挑战者”\*\*上场。既然擂主在 `i` 位置，那么第一个挑战者自然就从 `i+1` 开始。这个循环的目的就是在 `i` 之后的所有元素中，找到比当前 `minIndex` 所在位置的元素还要小的那一个。

-----

## 性能分析

  - **时间复杂度**: **$O(N^2)$** (最坏、平均、最好情况都是)

      - **原因**: 无论数组初始状态如何，它都需要完整的两层循环（约 $N^2/2$ 次比较）来找到每个位置的正确元素。比较次数是固定的，无法被优化。

  - **空间复杂度**: **$O(1)$**

      - **原因**: 只需要一个 `temp` 变量和 `minIndex` 变量，是**原地排序**算法。

  - **稳定性**: **不稳定 (Unstable)**

      - **原因**: 交换操作是“跳跃式”的。它会将找到的最小值，直接和当前轮次的第一个元素交换，这可能会打乱其他相等元素的原始相对顺序。
      - **示例**: 对 `[5a, 5b, 1]` 排序。
        1.  第一轮，找到最小值为 `1`。
        2.  将 `5a` 和 `1` 交换。
        3.  数组变为 `[1, 5b, 5a]`。
        4.  此时，`5a` 和 `5b` 的原始相对顺序被改变了。

-----

## 总结

  - **优点**:

    1.  **简单直观**，易于理解和实现。
    2.  最大的优点是**交换次数少**。在每一轮中，无论比较多少次，最多只进行**一次**交换。这在“交换操作成本远高于比较操作成本”的特殊场景下可能有奇效。

  - **缺点**:

    1.  时间复杂度高达 $O(N^2)$，性能不佳。
    2.  即使在数据基本有序的情况下也无法优化。

  - **适用场景**:
    主要用于**教学**。在实际应用中，除非数据量极小，或者交换成本极高，否则很少使用。

<!-- end list -->

```
```
